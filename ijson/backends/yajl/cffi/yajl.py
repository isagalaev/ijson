'''
CFFI-Wrapper for YAJL C library version 1.x.
'''

from cffi import FFI
import functools
import sys

import ijson.backends.yajl.common
from ijson.backends.yajl.cffi import require_version
from ijson import common
from ijson.compat import b2s

ffi = FFI()
ffi.cdef("""
typedef void * (*yajl_malloc_func)(void *ctx, unsigned int sz);
typedef void (*yajl_free_func)(void *ctx, void * ptr);
typedef void * (*yajl_realloc_func)(void *ctx, void * ptr, unsigned int sz);

typedef struct
{
    yajl_malloc_func malloc;
    yajl_realloc_func realloc;
    yajl_free_func free;
    void * ctx;
} yajl_alloc_funcs;

typedef struct yajl_handle_t * yajl_handle;

typedef enum {
    yajl_status_ok,
    yajl_status_client_canceled,
    yajl_status_error
} yajl_status;

typedef struct {
    int (* yajl_null)(void * ctx);
    int (* yajl_boolean)(void * ctx, int boolVal);
    int (* yajl_integer)(void * ctx, long integerVal);
    int (* yajl_double)(void * ctx, double doubleVal);
    int (* yajl_number)(void * ctx, const char * numberVal,
                        unsigned int numberLen);
    int (* yajl_string)(void * ctx, const unsigned char * stringVal,
                        unsigned int stringLen);
    int (* yajl_start_map)(void * ctx);
    int (* yajl_map_key)(void * ctx, const unsigned char * key,
                         unsigned int stringLen);
    int (* yajl_end_map)(void * ctx);
    int (* yajl_start_array)(void * ctx);
    int (* yajl_end_array)(void * ctx);
} yajl_callbacks;

typedef struct {
    unsigned int allowComments;
    unsigned int checkUTF8;
} yajl_parser_config;

yajl_handle yajl_alloc(const yajl_callbacks * callbacks,
                       const yajl_parser_config * config,
                       const yajl_alloc_funcs * allocFuncs,
                       void * ctx);

void yajl_free(yajl_handle handle);

yajl_status yajl_parse(yajl_handle hand,
                       const unsigned char * jsonText,
                       unsigned int jsonTextLength);

yajl_status yajl_parse_complete(yajl_handle hand);

unsigned char * yajl_get_error(yajl_handle hand, int verbose,
                               const unsigned char * jsonText,
                               unsigned int jsonTextLength);

void yajl_free_error(yajl_handle hand, unsigned char * str);

int yajl_version(void);
""")


try:
    yajl = ffi.dlopen('yajl')
except OSError:
    raise ImportError('Unable to load yajl')
# raises YAJLImportError if the version doesn't not match
require_version(yajl.yajl_version(), 1)


YAJL_OK = 0
YAJL_CANCELLED = 1
YAJL_INSUFFICIENT_DATA = 2
YAJL_ERROR = 3


def append_event_to_ctx(event):
    def wrapper(func):
        @functools.wraps(func)
        def wrapped(ctx, *args, **kwargs):
            value = func(*args, **kwargs)
            ctx = ffi.from_handle(ctx)
            ctx.append((event, value))
            return 1
        return wrapped
    return wrapper


@ffi.callback('int(void *ctx)')
@append_event_to_ctx('null')
def null():
    return None


@ffi.callback('int(void *ctx, int val)')
@append_event_to_ctx('boolean')
def boolean(val):
    return bool(val)


@ffi.callback('int(void *ctx, long integerVal)')
@append_event_to_ctx('integer')
def integer(val):
    return int(val)


@ffi.callback('int(void *ctx, double doubleVal)')
@append_event_to_ctx('double')
def double(val):
    return float(val)


@ffi.callback('int(void *ctx, const char *numberVal, unsigned int numberLen)')
@append_event_to_ctx('number')
def number(val, length):
    return common.number(b2s(ffi.string(val, maxlen=length)))


@ffi.callback('int(void *ctx, const unsigned char *stringVal, unsigned int stringLen)')
@append_event_to_ctx('string')
def string(val, length):
    return ffi.string(val, maxlen=length).decode('utf-8')


@ffi.callback('int(void *ctx)')
@append_event_to_ctx('start_map')
def start_map():
    return None


@ffi.callback('int(void *ctx, const unsigned char *key, unsigned int stringLen)')
@append_event_to_ctx('map_key')
def map_key(key, length):
    return b2s(ffi.string(key, maxlen=length))


@ffi.callback('int(void *ctx)')
@append_event_to_ctx('end_map')
def end_map():
    return None


@ffi.callback('int(void *ctx)')
@append_event_to_ctx('start_array')
def start_array():
    return None


@ffi.callback('int(void *ctx)')
@append_event_to_ctx('end_array')
def end_array():
    return None


_callback_data = (
    # For more information about callbacks,
    # take a look at the ctypes backend
    null, boolean, integer, double, number, string,
    start_map, map_key, end_map, start_array, end_array
)


def yajl_init(scope, events, allow_comments=False, check_utf8=False):
    scope.ctx = ffi.new_handle(events)
    scope.callbacks = ffi.new('yajl_callbacks*', _callback_data)
    config = ffi.new('yajl_parser_config*', (allow_comments, check_utf8))

    handle = yajl.yajl_alloc(scope.callbacks, config, ffi.NULL, scope.ctx)
    return handle


def yajl_parse(handle, buffer):
    if buffer:
        result = yajl.yajl_parse(handle, buffer, len(buffer))
    else:
        result = yajl.yajl_parse_complete(handle)

    if result != YAJL_OK:
        perror = yajl.yajl_get_error(handle, 1, buffer, len(buffer))
        error = ffi.string(perror)
        yajl.yajl_free_error(handle, perror)
        exception = common.IncompleteJSONError if result == YAJL_INSUFFICIENT_DATA else common.JSONError
        raise exception(error)


def yajl_free(handle):
    yajl.yajl_free(handle)


def basic_parse(f, buf_size=64*1024, allow_comments=False, check_utf8=False):
    _yajl = sys.modules[__name__]
    return ijson.backends.yajl.common.basic_parse(
        _yajl, f, buf_size=buf_size,
        allow_comments=allow_comments, check_utf8=check_utf8
    )

def parse(file, **kwargs):
    _yajl = sys.modules[__name__]
    return ijson.backends.yajl.common.parse(_yajl, file, **kwargs)


def items(file, prefix):
    _yajl = sys.modules[__name__]
    return ijson.backends.yajl.common.items(_yajl, file, prefix)
